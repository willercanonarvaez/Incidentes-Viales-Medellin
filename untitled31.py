# -*- coding: utf-8 -*-
"""Untitled31 (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yFWptd5LLQwkUopGoO670n8bCblk-jMc
"""
import streamlit as st
st.set_page_config(page_title="Dashboard de Incidentes Viales", layout="centered")

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# T√≠tulo principal
st.title("Incidentes Viales Medell√≠n 2018")

# Cargar con separador correcto y especificando la codificaci√≥n
df = pd.read_csv('incidentes viales.csv', encoding='latin-1', sep=None, engine='python')


# Filtro por comuna
comunas = df['COMUNA'].dropna().unique()
seleccion = st.selectbox("Selecciona una comuna", sorted(comunas))

# Filtrar datos por comuna
df_filtrado = df[df['COMUNA'] == seleccion]

# Gr√°fico de barras: tipos de incidente
st.subheader(f"Distribuci√≥n de tipos de incidente en la comuna {seleccion}")
fig, ax = plt.subplots()
sns.countplot(data=df_filtrado, x='CLASE', order=df_filtrado['CLASE'].value_counts().index, ax=ax)
ax.set_title(f"Tipos de incidente en {seleccion}")
plt.xticks(rotation=45)
st.pyplot(fig)

# Tabla de datos filtrados
st.subheader("Datos filtrados")
st.dataframe(df_filtrado[['FECHA', 'DIA_NOMBRE', 'CLASE', 'COMUNA', 'DIRECCION']])


import pandas as pd
# Update the path to the correct location of your CSV file
file_path = 'incidentes viales.csv'  # Replace with the correct path

# Confirmar que ahora s√≠ se cargan bien las columnas
print("N√∫mero de filas y columnas:", df.shape)
df.head()

# Tipos de datos y valores nulos

print(df.info())

# Revisi√≥n de valores √∫nicos por columna (muestra inicial)
print(df.nunique().sort_values())

# Valores faltantes
missing = df.isnull().sum()
missing = missing[missing > 0].sort_values(ascending=False)
print("Valores faltantes:\n", missing)

# Valores at√≠picos en variables num√©ricas
print(df.describe())

# Ver cu√°ntos son
print("Cantidad de filas con GRAVEDAD nula:", df['GRAVEDAD'].isnull().sum())

# Ver ejemplo de algunas de esas filas
df[df['GRAVEDAD'].isnull()].head()

# Eliminar filas con GRAVEDAD vac√≠a
df = df.dropna(subset=['GRAVEDAD'])

# Verificar que ya no hay nulos
print("Nuevos valores nulos en GRAVEDAD:", df['GRAVEDAD'].isnull().sum())

# Mostrar los primeros valores originales de la columna HORA
print("Valores originales en 'HORA':")
print(df['HORA'].head(20))

# Revisar cu√°ntos valores v√°lidos y cu√°ntos NaN quedaron despu√©s de la conversi√≥n
print("\nCantidad de NaN en HORA:", df['HORA'].isna().sum())
print("Cantidad de valores v√°lidos en HORA:", df['HORA'].notna().sum())

# Convertir DIA y MES a num√©rico
df['DIA'] = pd.to_numeric(df['DIA'], errors='coerce')
df['MES'] = pd.to_numeric(df['MES'], errors='coerce')

# Convertir HORA a decimal (ej: "08:30" ‚Üí 8.5)
df['HORA'] = pd.to_datetime(df['HORA'], errors='coerce')
df['HORA_DECIMAL'] = df['HORA'].dt.hour + df['HORA'].dt.minute / 60

# Asegurarse de que HORA_DECIMAL es num√©rica
df['HORA_DECIMAL'] = pd.to_numeric(df['HORA_DECIMAL'], errors='coerce')

# Crear la columna 'Jornada' con clasificaci√≥n simplificada
def jornada_simplificada(hora):
    if pd.isna(hora):
        return 'Desconocida'
    elif 0 <= hora <= 6:
        return 'Madrugada'
    else:
        return 'Ma√±ana'

df['Jornada'] = df['HORA_DECIMAL'].apply(jornada_simplificada)


# Crear una variable num√©rica que indique si fue fin de semana
def identificar_fin_de_semana(dia):
    if dia in ['SABADO', 'DOMINGO']:
        return 1
    else:
        return 0

# Aplicar la funci√≥n
df['Fin_de_Semana'] = df['DIA_NOMBRE'].apply(identificar_fin_de_semana)

# (Opcional) Verificar
print(df[['DIA_NOMBRE', 'Fin_de_Semana']].head(70))

import pandas as pd
import plotly.express as px
import streamlit as st
from pyproj import Transformer

st.subheader(" Distribuci√≥n de GRAVEDAD seg√∫n CLASE del incidente")

fig1 = px.histogram(df, x='CLASE', color='GRAVEDAD', barmode='stack',
                    title='Distribuci√≥n de Gravedad por Tipo de Incidente',
                    labels={'CLASE': 'Tipo de incidente', 'count': 'Cantidad'})
st.plotly_chart(fig1, use_container_width=True)


st.subheader(" Tendencia mensual de incidentes por Jornada")

# Agrupar por MES y JORNADA
df['Jornada'] = df['Jornada'].fillna('Desconocida')
df['MES'] = pd.to_numeric(df['MES'], errors='coerce')

tendencia = df.groupby(['MES', 'Jornada']).size().reset_index(name='Cantidad')

# Crear gr√°fico de √°rea apilada
fig = px.area(
    tendencia,
    x='MES',
    y='Cantidad',
    color='Jornada',
    line_group='Jornada',
    title="Tendencia mensual de incidentes por Jornada",
    color_discrete_sequence=px.colors.qualitative.Pastel
)

# Personalizar
fig.update_layout(
    height=650,
    title_font=dict(size=24),
    legend_title_text='Tipo de Jornada',
    hovermode='x unified',
    title_x=0.5
)

# Mostrar en Streamlit
st.plotly_chart(fig, use_container_width=True)

import streamlit as st
import plotly.express as px
import pandas as pd

st.subheader("Heatmap Interactivo D√≠a vs Hora")

# Slider para rango de d√≠as y horas
dia_range = st.slider("Selecciona el rango de d√≠as del mes", 1, 31, (1, 31))
hora_range = st.slider("Selecciona el rango de horas del d√≠a", 0, 23, (0, 23))

# Filtro seg√∫n sliders
df_filtrado = df[
    (df['DIA'].between(dia_range[0], dia_range[1])) &
    (df['HORA_DECIMAL'].between(hora_range[0], hora_range[1]))
]

# Agrupaci√≥n
heatmap = df_filtrado.groupby(['DIA', 'HORA_DECIMAL']).size().reset_index(name='Conteo')

# Dropdown para cambiar color
color_paleta = st.selectbox(" Escala de color", ['Viridis', 'Cividis', 'Plasma', 'Turbo', 'Icefire'])

# Heatmap con hover y escala din√°mica
fig = px.density_heatmap(
    heatmap,
    x='HORA_DECIMAL',
    y='DIA',
    z='Conteo',
    nbinsx=24,
    nbinsy=31,
    color_continuous_scale=color_paleta,
    title=f"Mapa de Calor Interactivo: D√çA vs HORA (D√≠as {dia_range[0]} a {dia_range[1]})"
)

fig.update_layout(height=600, title_x=0.5)

st.plotly_chart(fig, use_container_width=True)

import pandas as pd
import plotly.express as px
import streamlit as st
from pyproj import Transformer

st.subheader(" Mapa de Incidentes por Direcci√≥n y Gravedad (Medell√≠n)")

# Usar X_MAGNAMED como LONGITUD y Y_MAGNAMED como LATITUD
df['X_MAGNAMED'] = pd.to_numeric(df['X_MAGNAMED'], errors='coerce')
df['Y_MAGNAMED'] = pd.to_numeric(df['Y_MAGNAMED'], errors='coerce')

# Transformador de EPSG:3116 (MAGNA Colombia) a WGS84
transformador = Transformer.from_crs("EPSG:3116", "EPSG:4326", always_xy=True)

try:
    # Transformar coordenadas
    df[['LONGITUD_CONV', 'LATITUD_CONV']] = df.apply(
        lambda row: pd.Series(transformador.transform(row['X_MAGNAMED'], row['Y_MAGNAMED'])),
        axis=1
    )

    geo_df = df.dropna(subset=['LATITUD_CONV', 'LONGITUD_CONV'])

    if not geo_df.empty:
        fig = px.scatter_mapbox(
            geo_df,
            lat='LATITUD_CONV',
            lon='LONGITUD_CONV',
            color='GRAVEDAD' if 'GRAVEDAD' in df.columns else None,
            hover_name='DIRECCION' if 'DIRECCION' in df.columns else None,
            zoom=11,
            height=500,
            title='Mapa de Incidentes en Medell√≠n (coordenadas convertidas)'
        )
        fig.update_layout(mapbox_style='open-street-map')
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.warning("No se encontraron coordenadas transformadas v√°lidas para mostrar el mapa.")

except Exception as e:
    st.error(f" Error al convertir coordenadas: {e}")

st.subheader("Distribuci√≥n de HORA_DECIMAL por GRAVEDAD (seg√∫n Jornada)")

fig = px.violin(df, y="HORA_DECIMAL", x="GRAVEDAD", color="Jornada",
                box=True, points="all", hover_data=["DIA", "MES", "CLASE"],
                title="Violin Plot de Horas por Gravedad y Jornada")
st.plotly_chart(fig, use_container_width=True)


st.subheader(" Distribuci√≥n de CLASE de incidente separada por Jornada")

fig = px.histogram(df, x="CLASE", color="GRAVEDAD",
                   facet_col="Jornada", barmode="group",
                   title="Tipos de Incidentes por Gravedad y Jornada")
st.plotly_chart(fig, use_container_width=True)


st.subheader("Tendencia mensual de incidentes (Semana vs Fin de Semana)")

df['Tipo_Dia'] = df['Fin_de_Semana'].map({0: 'Semana', 1: 'Fin de Semana'})
trend = df.groupby(['MES', 'Tipo_Dia']).size().reset_index(name='Cantidad')

fig = px.line(trend, x="MES", y="Cantidad", color="Tipo_Dia", markers=True,
              title="Tendencia mensual de incidentes seg√∫n tipo de d√≠a")
st.plotly_chart(fig, use_container_width=True)



st.subheader("Jerarqu√≠a de incidentes: Gravedad > Clase > Jornada")

fig = px.sunburst(df, path=['GRAVEDAD', 'CLASE', 'Jornada'],
                  title="Distribuci√≥n jer√°rquica de los incidentes")
st.plotly_chart(fig, use_container_width=True)


import streamlit as st
import pandas as pd
import plotly.express as px

st.subheader("Treemap de Incidentes por Gravedad, Clase y Comuna")

# Asegurar limpieza de texto
df['GRAVEDAD'] = df['GRAVEDAD'].astype(str).str.upper().str.strip()
df['CLASE'] = df['CLASE'].astype(str).str.upper().str.strip()
df['COMUNA'] = df['COMUNA'].astype(str).str.upper().str.strip()

# Agrupar por GRAVEDAD > CLASE > COMUNA con cantidad expl√≠cita
treemap_data = df.groupby(['GRAVEDAD', 'CLASE', 'COMUNA']).size().reset_index(name='Cantidad')

# Crear Treemap
fig = px.treemap(
    treemap_data,
    path=['GRAVEDAD', 'CLASE', 'COMUNA'],
    values='Cantidad',
    color='GRAVEDAD',
    title='Treemap: GRAVEDAD > CLASE > COMUNA (incluye MUERTO)'
)

st.plotly_chart(fig, use_container_width=True)

import plotly.express as px
import streamlit as st
import pandas as pd

st.subheader("Incidentes por comuna (animaci√≥n mensual estilo pastel)")

# Asegurar limpieza
df['COMUNA'] = df['COMUNA'].astype(str).str.upper().str.strip()
df_anim = df.groupby(['MES', 'COMUNA']).size().reset_index(name='Cantidad')

# Gr√°fico con colores pastel
fig = px.bar(
    df_anim,
    x='COMUNA',
    y='Cantidad',
    color='COMUNA',
    animation_frame='MES',
    range_y=[0, df_anim['Cantidad'].max() + 50],
    title="Incidentes por comuna (animaci√≥n mensual)",
    height=600,
    color_discrete_sequence=px.colors.qualitative.Pastel  # üëà COLORES PASTEL
)

fig.update_layout(
    xaxis_tickangle=-45,
    xaxis_title='Comuna',
    yaxis_title='Cantidad de incidentes',
    title_x=0.5
)

st.plotly_chart(fig, use_container_width=True)


st.subheader("Dashboard por filtros")

filtro_gravedad = st.selectbox("Selecciona gravedad", df['GRAVEDAD'].dropna().unique())
filtro_jornada = st.selectbox("Selecciona jornada", df['Jornada'].dropna().unique())

filtro_df = df[(df['GRAVEDAD'] == filtro_gravedad) & (df['Jornada'] == filtro_jornada)]

tabs = st.tabs(["Boxplot", " Mapa", "Tendencia"])

with tabs[0]:
    fig = px.box(filtro_df, x='CLASE', y='HORA_DECIMAL', color='CLASE',
                 title="Boxplot por clase")
    st.plotly_chart(fig, use_container_width=True)

with tabs[1]:
    if 'LATITUD_CONV' in filtro_df.columns:
        fig = px.scatter_map(filtro_df, lat='LATITUD_CONV', lon='LONGITUD_CONV',
                             color='CLASE', title='Mapa filtrado')
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("No hay coordenadas para mostrar.")

with tabs[2]:
    tendencia = filtro_df.groupby('MES').size().reset_index(name='Cantidad')
    fig = px.line(tendencia, x='MES', y='Cantidad', markers=True,
                  title="Tendencia mensual")
    st.plotly_chart(fig, use_container_width=True)


import plotly.express as px
import streamlit as st

st.subheader(" Gr√°fico 3D de Incidentes: Hora, D√≠a y Gravedad")

# Limpiar datos
df['HORA_DECIMAL'] = pd.to_numeric(df['HORA_DECIMAL'], errors='coerce')
df['DIA'] = pd.to_numeric(df['DIA'], errors='coerce')
df['GRAVEDAD'] = df['GRAVEDAD'].astype(str).str.upper().str.strip()

# Agrupamos
data_3d = df.groupby(['DIA', 'HORA_DECIMAL', 'GRAVEDAD']).size().reset_index(name='Cantidad')

# Gr√°fico 3D
fig = px.scatter_3d(
    data_3d,
    x='DIA',
    y='HORA_DECIMAL',
    z='Cantidad',
    color='GRAVEDAD',
    size='Cantidad',
    symbol='GRAVEDAD',
    opacity=0.8,
    title='Incidentes Viales 3D: D√≠a vs Hora vs Cantidad (coloreado por Gravedad)',
    color_discrete_sequence=px.colors.qualitative.Pastel
)

fig.update_layout(height=700, scene=dict(
    xaxis_title='D√≠a del Mes',
    yaxis_title='Hora Decimal',
    zaxis_title='Cantidad de Incidentes'
))

st.plotly_chart(fig, use_container_width=True)



import streamlit as st
import plotly.graph_objects as go
import pandas as pd

st.subheader("Superficie 3D de Incidentes por D√≠a y Hora")

# Agrupar los datos
df_filtrado = df[['DIA', 'HORA_DECIMAL']].dropna()
conteo = df_filtrado.groupby(['DIA', 'HORA_DECIMAL']).size().reset_index(name='Cantidad')

# Pivot para crear la "malla" de superficie
z_data = conteo.pivot(index='DIA', columns='HORA_DECIMAL', values='Cantidad').fillna(0)

# Crear figura
fig = go.Figure(data=[go.Surface(
    z=z_data.values,
    x=z_data.columns,
    y=z_data.index,
    colorscale='Viridis',  # Otros: 'Cividis', 'Inferno', 'Plasma', 'Turbo'
    showscale=True
)])

# Opciones de la gr√°fica
fig.update_layout(
    title='Distribuci√≥n de incidentes por D√≠a y Hora',
    scene=dict(
        xaxis_title='Hora',
        yaxis_title='D√≠a',
        zaxis_title='Cantidad',
        camera=dict(eye=dict(x=1.5, y=1.5, z=1.2))
    ),
    height=750
)

st.plotly_chart(fig, use_container_width=True)
