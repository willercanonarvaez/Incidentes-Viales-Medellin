# -*- coding: utf-8 -*-
"""Untitled31 (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yFWptd5LLQwkUopGoO670n8bCblk-jMc
"""
import streamlit as st
st.set_page_config(page_title="Dashboard de Incidentes Viales", layout="centered")

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Título principal
st.title("Incidentes Viales Medellín 2018")

# Cargar con separador correcto y especificando la codificación
df = pd.read_csv('incidentes viales.csv', encoding='latin-1', sep=None, engine='python')


# Filtro por comuna
comunas = df['COMUNA'].dropna().unique()
seleccion = st.selectbox("Selecciona una comuna", sorted(comunas))

# Filtrar datos por comuna
df_filtrado = df[df['COMUNA'] == seleccion]

# Gráfico de barras: tipos de incidente
st.subheader(f"Distribución de tipos de incidente en la comuna {seleccion}")
fig, ax = plt.subplots()
sns.countplot(data=df_filtrado, x='CLASE', order=df_filtrado['CLASE'].value_counts().index, ax=ax)
ax.set_title(f"Tipos de incidente en {seleccion}")
plt.xticks(rotation=45)
st.pyplot(fig)

# Tabla de datos filtrados
st.subheader("Datos filtrados")
st.dataframe(df_filtrado[['FECHA', 'DIA_NOMBRE', 'CLASE', 'COMUNA', 'DIRECCION']])


import pandas as pd
# Update the path to the correct location of your CSV file
file_path = 'incidentes viales.csv'  # Replace with the correct path

# Confirmar que ahora sí se cargan bien las columnas
print("Número de filas y columnas:", df.shape)
df.head()

# Tipos de datos y valores nulos

print(df.info())

# Revisión de valores únicos por columna (muestra inicial)
print(df.nunique().sort_values())

# Valores faltantes
missing = df.isnull().sum()
missing = missing[missing > 0].sort_values(ascending=False)
print("Valores faltantes:\n", missing)

# Valores atípicos en variables numéricas
print(df.describe())

# Ver cuántos son
print("Cantidad de filas con GRAVEDAD nula:", df['GRAVEDAD'].isnull().sum())

# Ver ejemplo de algunas de esas filas
df[df['GRAVEDAD'].isnull()].head()

# Eliminar filas con GRAVEDAD vacía
df = df.dropna(subset=['GRAVEDAD'])

# Verificar que ya no hay nulos
print("Nuevos valores nulos en GRAVEDAD:", df['GRAVEDAD'].isnull().sum())

# Mostrar los primeros valores originales de la columna HORA
print("Valores originales en 'HORA':")
print(df['HORA'].head(20))

# Revisar cuántos valores válidos y cuántos NaN quedaron después de la conversión
print("\nCantidad de NaN en HORA:", df['HORA'].isna().sum())
print("Cantidad de valores válidos en HORA:", df['HORA'].notna().sum())

# Convertir DIA y MES a numérico
df['DIA'] = pd.to_numeric(df['DIA'], errors='coerce')
df['MES'] = pd.to_numeric(df['MES'], errors='coerce')

# Convertir HORA a decimal (ej: "08:30" → 8.5)
df['HORA'] = pd.to_datetime(df['HORA'], errors='coerce')
df['HORA_DECIMAL'] = df['HORA'].dt.hour + df['HORA'].dt.minute / 60

# Asegurarse de que HORA_DECIMAL es numérica
df['HORA_DECIMAL'] = pd.to_numeric(df['HORA_DECIMAL'], errors='coerce')

# Crear la columna 'Jornada' con clasificación simplificada
def jornada_simplificada(hora):
    if pd.isna(hora):
        return 'Desconocida'
    elif 0 <= hora <= 6:
        return 'Madrugada'
    else:
        return 'Mañana'

df['Jornada'] = df['HORA_DECIMAL'].apply(jornada_simplificada)


# Crear una variable numérica que indique si fue fin de semana
def identificar_fin_de_semana(dia):
    if dia in ['SABADO', 'DOMINGO']:
        return 1
    else:
        return 0

# Aplicar la función
df['Fin_de_Semana'] = df['DIA_NOMBRE'].apply(identificar_fin_de_semana)

# (Opcional) Verificar
print(df[['DIA_NOMBRE', 'Fin_de_Semana']].head(70))

import pandas as pd
import plotly.express as px
import streamlit as st
from pyproj import Transformer

st.subheader(" Distribución de GRAVEDAD según CLASE del incidente")

fig1 = px.histogram(df, x='CLASE', color='GRAVEDAD', barmode='stack',
                    title='Distribución de Gravedad por Tipo de Incidente',
                    labels={'CLASE': 'Tipo de incidente', 'count': 'Cantidad'})
st.plotly_chart(fig1, use_container_width=True)


st.subheader(" Tendencia mensual de incidentes por Jornada")

# Agrupar por MES y JORNADA
df['Jornada'] = df['Jornada'].fillna('Desconocida')
df['MES'] = pd.to_numeric(df['MES'], errors='coerce')

tendencia = df.groupby(['MES', 'Jornada']).size().reset_index(name='Cantidad')

# Crear gráfico de área apilada
fig = px.area(
    tendencia,
    x='MES',
    y='Cantidad',
    color='Jornada',
    line_group='Jornada',
    title="Tendencia mensual de incidentes por Jornada",
    color_discrete_sequence=px.colors.qualitative.Pastel
)

# Personalizar
fig.update_layout(
    height=650,
    title_font=dict(size=24),
    legend_title_text='Tipo de Jornada',
    hovermode='x unified',
    title_x=0.5
)

# Mostrar en Streamlit
st.plotly_chart(fig, use_container_width=True)

import streamlit as st
import plotly.express as px
import pandas as pd

st.subheader("Heatmap Interactivo Día vs Hora")

# Slider para rango de días y horas
dia_range = st.slider("Selecciona el rango de días del mes", 1, 31, (1, 31))
hora_range = st.slider("Selecciona el rango de horas del día", 0, 23, (0, 23))

# Filtro según sliders
df_filtrado = df[
    (df['DIA'].between(dia_range[0], dia_range[1])) &
    (df['HORA_DECIMAL'].between(hora_range[0], hora_range[1]))
]

# Agrupación
heatmap = df_filtrado.groupby(['DIA', 'HORA_DECIMAL']).size().reset_index(name='Conteo')

# Dropdown para cambiar color
color_paleta = st.selectbox(" Escala de color", ['Viridis', 'Cividis', 'Plasma', 'Turbo', 'Icefire'])

# Heatmap con hover y escala dinámica
fig = px.density_heatmap(
    heatmap,
    x='HORA_DECIMAL',
    y='DIA',
    z='Conteo',
    nbinsx=24,
    nbinsy=31,
    color_continuous_scale=color_paleta,
    title=f"Mapa de Calor Interactivo: DÍA vs HORA (Días {dia_range[0]} a {dia_range[1]})"
)

fig.update_layout(height=600, title_x=0.5)

st.plotly_chart(fig, use_container_width=True)

import pandas as pd
import plotly.express as px
import streamlit as st
from pyproj import Transformer

st.subheader(" Mapa de Incidentes por Dirección y Gravedad (Medellín)")

# Usar X_MAGNAMED como LONGITUD y Y_MAGNAMED como LATITUD
df['X_MAGNAMED'] = pd.to_numeric(df['X_MAGNAMED'], errors='coerce')
df['Y_MAGNAMED'] = pd.to_numeric(df['Y_MAGNAMED'], errors='coerce')

# Transformador de EPSG:3116 (MAGNA Colombia) a WGS84
transformador = Transformer.from_crs("EPSG:3116", "EPSG:4326", always_xy=True)

try:
    # Transformar coordenadas
    df[['LONGITUD_CONV', 'LATITUD_CONV']] = df.apply(
        lambda row: pd.Series(transformador.transform(row['X_MAGNAMED'], row['Y_MAGNAMED'])),
        axis=1
    )

    geo_df = df.dropna(subset=['LATITUD_CONV', 'LONGITUD_CONV'])

    if not geo_df.empty:
        fig = px.scatter_mapbox(
            geo_df,
            lat='LATITUD_CONV',
            lon='LONGITUD_CONV',
            color='GRAVEDAD' if 'GRAVEDAD' in df.columns else None,
            hover_name='DIRECCION' if 'DIRECCION' in df.columns else None,
            zoom=11,
            height=500,
            title='Mapa de Incidentes en Medellín (coordenadas convertidas)'
        )
        fig.update_layout(mapbox_style='open-street-map')
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.warning("No se encontraron coordenadas transformadas válidas para mostrar el mapa.")

except Exception as e:
    st.error(f" Error al convertir coordenadas: {e}")

st.subheader("Distribución de HORA_DECIMAL por GRAVEDAD (según Jornada)")

fig = px.violin(df, y="HORA_DECIMAL", x="GRAVEDAD", color="Jornada",
                box=True, points="all", hover_data=["DIA", "MES", "CLASE"],
                title="Violin Plot de Horas por Gravedad y Jornada")
st.plotly_chart(fig, use_container_width=True)


st.subheader(" Distribución de CLASE de incidente separada por Jornada")

fig = px.histogram(df, x="CLASE", color="GRAVEDAD",
                   facet_col="Jornada", barmode="group",
                   title="Tipos de Incidentes por Gravedad y Jornada")
st.plotly_chart(fig, use_container_width=True)


st.subheader("Tendencia mensual de incidentes (Semana vs Fin de Semana)")

df['Tipo_Dia'] = df['Fin_de_Semana'].map({0: 'Semana', 1: 'Fin de Semana'})
trend = df.groupby(['MES', 'Tipo_Dia']).size().reset_index(name='Cantidad')

fig = px.line(trend, x="MES", y="Cantidad", color="Tipo_Dia", markers=True,
              title="Tendencia mensual de incidentes según tipo de día")
st.plotly_chart(fig, use_container_width=True)



st.subheader("Jerarquía de incidentes: Gravedad > Clase > Jornada")

fig = px.sunburst(df, path=['GRAVEDAD', 'CLASE', 'Jornada'],
                  title="Distribución jerárquica de los incidentes")
st.plotly_chart(fig, use_container_width=True)


import streamlit as st
import pandas as pd
import plotly.express as px

st.subheader("Treemap de Incidentes por Gravedad, Clase y Comuna")

# Asegurar limpieza de texto
df['GRAVEDAD'] = df['GRAVEDAD'].astype(str).str.upper().str.strip()
df['CLASE'] = df['CLASE'].astype(str).str.upper().str.strip()
df['COMUNA'] = df['COMUNA'].astype(str).str.upper().str.strip()

# Agrupar por GRAVEDAD > CLASE > COMUNA con cantidad explícita
treemap_data = df.groupby(['GRAVEDAD', 'CLASE', 'COMUNA']).size().reset_index(name='Cantidad')

# Crear Treemap
fig = px.treemap(
    treemap_data,
    path=['GRAVEDAD', 'CLASE', 'COMUNA'],
    values='Cantidad',
    color='GRAVEDAD',
    title='Treemap: GRAVEDAD > CLASE > COMUNA (incluye MUERTO)'
)

st.plotly_chart(fig, use_container_width=True)

import plotly.express as px
import streamlit as st
import pandas as pd

st.subheader("Incidentes por comuna (animación mensual estilo pastel)")

# Asegurar limpieza
df['COMUNA'] = df['COMUNA'].astype(str).str.upper().str.strip()
df_anim = df.groupby(['MES', 'COMUNA']).size().reset_index(name='Cantidad')

# Gráfico con colores pastel
fig = px.bar(
    df_anim,
    x='COMUNA',
    y='Cantidad',
    color='COMUNA',
    animation_frame='MES',
    range_y=[0, df_anim['Cantidad'].max() + 50],
    title="Incidentes por comuna (animación mensual)",
    height=600,
    color_discrete_sequence=px.colors.qualitative.Pastel  # 👈 COLORES PASTEL
)

fig.update_layout(
    xaxis_tickangle=-45,
    xaxis_title='Comuna',
    yaxis_title='Cantidad de incidentes',
    title_x=0.5
)

st.plotly_chart(fig, use_container_width=True)


st.subheader("Dashboard por filtros")

filtro_gravedad = st.selectbox("Selecciona gravedad", df['GRAVEDAD'].dropna().unique())
filtro_jornada = st.selectbox("Selecciona jornada", df['Jornada'].dropna().unique())

filtro_df = df[(df['GRAVEDAD'] == filtro_gravedad) & (df['Jornada'] == filtro_jornada)]

tabs = st.tabs(["Boxplot", " Mapa", "Tendencia"])

with tabs[0]:
    fig = px.box(filtro_df, x='CLASE', y='HORA_DECIMAL', color='CLASE',
                 title="Boxplot por clase")
    st.plotly_chart(fig, use_container_width=True)

with tabs[1]:
    if 'LATITUD_CONV' in filtro_df.columns:
        fig = px.scatter_map(filtro_df, lat='LATITUD_CONV', lon='LONGITUD_CONV',
                             color='CLASE', title='Mapa filtrado')
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.info("No hay coordenadas para mostrar.")

with tabs[2]:
    tendencia = filtro_df.groupby('MES').size().reset_index(name='Cantidad')
    fig = px.line(tendencia, x='MES', y='Cantidad', markers=True,
                  title="Tendencia mensual")
    st.plotly_chart(fig, use_container_width=True)


import plotly.express as px
import streamlit as st

st.subheader(" Gráfico 3D de Incidentes: Hora, Día y Gravedad")

# Limpiar datos
df['HORA_DECIMAL'] = pd.to_numeric(df['HORA_DECIMAL'], errors='coerce')
df['DIA'] = pd.to_numeric(df['DIA'], errors='coerce')
df['GRAVEDAD'] = df['GRAVEDAD'].astype(str).str.upper().str.strip()

# Agrupamos
data_3d = df.groupby(['DIA', 'HORA_DECIMAL', 'GRAVEDAD']).size().reset_index(name='Cantidad')

# Gráfico 3D
fig = px.scatter_3d(
    data_3d,
    x='DIA',
    y='HORA_DECIMAL',
    z='Cantidad',
    color='GRAVEDAD',
    size='Cantidad',
    symbol='GRAVEDAD',
    opacity=0.8,
    title='Incidentes Viales 3D: Día vs Hora vs Cantidad (coloreado por Gravedad)',
    color_discrete_sequence=px.colors.qualitative.Pastel
)

fig.update_layout(height=700, scene=dict(
    xaxis_title='Día del Mes',
    yaxis_title='Hora Decimal',
    zaxis_title='Cantidad de Incidentes'
))

st.plotly_chart(fig, use_container_width=True)



import streamlit as st
import plotly.graph_objects as go
import pandas as pd

st.subheader("Superficie 3D de Incidentes por Día y Hora")

# Agrupar los datos
df_filtrado = df[['DIA', 'HORA_DECIMAL']].dropna()
conteo = df_filtrado.groupby(['DIA', 'HORA_DECIMAL']).size().reset_index(name='Cantidad')

# Pivot para crear la "malla" de superficie
z_data = conteo.pivot(index='DIA', columns='HORA_DECIMAL', values='Cantidad').fillna(0)

# Crear figura
fig = go.Figure(data=[go.Surface(
    z=z_data.values,
    x=z_data.columns,
    y=z_data.index,
    colorscale='Viridis',  # Otros: 'Cividis', 'Inferno', 'Plasma', 'Turbo'
    showscale=True
)])

# Opciones de la gráfica
fig.update_layout(
    title='Distribución de incidentes por Día y Hora',
    scene=dict(
        xaxis_title='Hora',
        yaxis_title='Día',
        zaxis_title='Cantidad',
        camera=dict(eye=dict(x=1.5, y=1.5, z=1.2))
    ),
    height=750
)

st.plotly_chart(fig, use_container_width=True)
